Below are 10 issues discovered in the repository.

1. Duplicate Imports (backend_simplified/main.py)
Lines 9–15 contain repeated imports of logging and asynccontextmanager:

     9  import logging
    10  from contextlib import asynccontextmanager
    11  import logging
...
    14  from fastapi import FastAPI
    15  from contextlib import asynccontextmanager

Why it’s a bug: Duplicate imports bloat the module and can lead to confusion about which objects are actually used.

Fix: Remove the duplicated lines so each module is imported once.

2. Startup Log Message Lacks Formatting (backend_simplified/main.py)
The code logs a multiline message without using an f-string:

    55      logger.info("""
    56  ========== APPLICATION STARTUP ==========
    57  FILE: main.py
...
    62  DEBUG: {BACKEND_API_DEBUG}
    63  =========================================""")

Why it’s a bug: String interpolation does not occur, so the placeholders {BACKEND_API_PORT}, {BACKEND_API_HOST}, etc., appear literally in logs.

Fix: Use an f-string (logger.info(f"""...""")) or format the string explicitly.

3. Use of asyncio.get_event_loop() (backend_simplified/main.py)
At line 87:

    loop = asyncio.get_event_loop()

Why it’s a bug: In modern Python versions, asyncio.get_event_loop() may raise a RuntimeError if no event loop is set. asyncio.get_running_loop() is safer inside async contexts.

Fix: Replace with loop = asyncio.get_running_loop() (inside async function) or create a new loop if necessary.

4. Missing Trailing Newline (frontend/src/hooks/usePerformance.ts)
The file ends without a newline:

   414    return { metrics, isLoading, isError };
   415  }

Why it’s a bug: Many linters and POSIX tools expect files to end with a newline. Missing newlines can cause issues when concatenating files or generating patches.

Fix: Add a newline at the end of the file.

5. Missing test Script (e2e_test_suite/package.json)
package.json defines various scripts but no "test" command:

5:  "scripts": {
6-    "test:e2e": "playwright test",
...

Why it’s a bug: Running npm test fails with “Missing script: test,” which breaks common workflows.

Fix: Add a "test": "npm run test:e2e" entry (or similar) to the scripts section.

6. Missing Trailing Newline (backend_simplified/scripts/load_market_holidays.py)
The script ends without a newline:

   153  if __name__ == "__main__":
   154      asyncio.run(main())

Why it’s a bug: Similar to issue 4, missing a final newline can cause patching or formatting problems.

Fix: Ensure the file ends with a newline.

7. Bare raise Statements (supa_api modules)
Several functions re‑raise exceptions with a bare raise:

        except Exception as e:
            DebugLogger.log_error(
                file_name="supa_api_client.py",
                function_name="_initialize_clients",
                error=e
            )
            raise

Why it’s a bug: While re‑raising is valid, a bare raise can obscure the original traceback if the exception is caught elsewhere.

Fix: If additional context is needed, use raise e or re‑raise with a custom exception preserving from e.

8. Multiple Files Lack Trailing Newlines
Examples include backend_simplified/utils/auth_helpers.py and the hooks in frontend/src/hooks/. The final line ends without a newline:

    return user_id

Why it’s a bug: As with issue 4, missing EOF newlines can cause tooling inconsistencies.

Fix: Ensure every source file ends with a newline.

9. Dead Commented Code (various TODOs)
Several modules contain TODO comments such as:

# TODO: derive from yesterday's prices.

Why it’s a bug: Unimplemented sections may indicate incomplete logic, leading to missing or inaccurate data.

Fix: Implement the commented functionality or remove outdated TODOs.

10. npm test Failure Demonstrated
Running npm test in e2e_test_suite fails:

npm ERR! Missing script: "test"
npm ERR! To see a list of scripts, run:
npm ERR!   npm run

Why it’s a bug: A developer expects npm test to execute tests, but it fails because the script is undefined.

Fix: As in issue 5, define a test script or document the correct command.

Summary

Missing utility import – layout.tsx imports patchConsole from @/lib/debug, but no such file exists, so Next.js will fail to compile.
Lines showing the import:

Unformatted logging message – In main.py a multiline log string is not an f‑string, so variables such as {BACKEND_API_PORT} are printed literally.
Lines showing the issue:

Cache expiration ignored – vantage_api_client.py writes an expires_at timestamp when saving to the cache but only checks created_at when reading, so data never expires.
Relevant code:

Missing module front_api_client – Several frontend files import @/lib/front_api_client, but this module does not exist anywhere in the repo (confirmed with find).
Example import:
Missing module search:

Undefined function usage – CompanyIcon.tsx calls setError in an onError handler, but useCompanyIcon does not return this function, causing a runtime reference error.
Usage site:
Hook return value:

Division by zero – When computing total_profit_percent in AnalyticsPage, dividing by allocation.cost_basis can yield Infinity when the cost basis is 0. The || 0 fallback does not prevent this.
Calculation line:

Invalid Playwright API call – The E2E test uses element.clear(), but Playwright locators have no clear() method. This will throw during test execution.
Line in question:

Sensitive credentials committed – e2e_test_suite/config/test.env contains hard‑coded user credentials and API keys.
Example lines:

TypeScript compilation failures – Running tsc produces many errors (missing React types, missing modules, etc.), showing the project does not compile cleanly.
Sample output:

Extraneous text in config – next.config.js ends with a shell prompt string, which causes a syntax error.
File tail:

How to Fix

Add the missing debug.ts (implementing patchConsole) or remove the import/call.

Prefix the multiline logging string with f to interpolate variables.

When reading from the cache, compare expires_at with the current time instead of created_at, or remove the unused field.

Create the front_api_client module or update all imports to the correct path.

Return setError from useCompanyIcon or handle errors differently (e.g., via internal state only).

Check if allocation.cost_basis is zero before dividing; return 0 in that case.

Replace element.clear() with await element.fill('').

Move credentials to a secure location (e.g., environment variables) and exclude them from version control.

Install the missing type packages and ensure all referenced modules exist so tsc runs without errors.

Remove the stray shell prompt text so the file ends with module.exports = nextConfig.

Below are 10 issues detected in the repository.
For each item you’ll find a short explanation and a suggested fix.

1. Unused import in AddDividendModal.tsx
The component imports front_api_get_quote but never calls it:

import { front_api_search_symbols, front_api_get_quote } from '@/lib/front_api_client';

Why it’s a bug: Unused imports increase bundle size and make the code harder to read.

Fix: Remove front_api_get_quote from the import line or use it in the component.

2–4. Issues inside AddDividendModal.tsx hook logic
Snippet:

    setForm(initialFormState);
  }, [isOpen]);

  const handleFormChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      const { name, value, type } = e.target;
      const isCheckbox = (e.target as HTMLInputElement).type === 'checkbox';

Additional part:

    const handleTickerSearch = useCallback(debounce(async (query: string) => {
        if (query.length < 1) {
            setTickerSuggestions([]);
            return;
        }

Another part:

        } catch (error) {
            setTickerSuggestions([]);
        } finally {
            setSearchLoading(false);
        }

Issues:

initialFormState is used inside useEffect but isn’t included in the dependency array.

Variable type is captured from e.target but never used.

handleTickerSearch’s dependencies are unknown, triggering ESLint warnings.

The error variable in the catch block is never read.

Fixes:

Add initialFormState to the dependency list of useEffect.

Remove type if it’s unnecessary.

Ensure dependencies of useCallback are correct ([searchCache], etc.).

Use the error value for logging or remove the variable.

5. Unused import in AnalyticsDividendsTab.tsx
  isDividendConfirmable,
  getCompanyDisplayName
} from '@/types/dividend';

isDividendConfirmable is never referenced.

Fix: Delete the unused import or use the helper if needed.

6. Effect missing dependency in AnalyticsDividendsTab.tsx
  useEffect(() => {
    if (!hasAutoSynced.current && !syncDividendsMutation.isPending) {
      hasAutoSynced.current = true;
      syncDividendsMutation.mutate();
    }
  }, []);

Why it’s a bug: ESLint warns that syncDividendsMutation is used inside the effect but not listed in its dependency array.

Fix: Add syncDividendsMutation to the dependency list or refactor to ensure the effect runs correctly.

7. Unused import in AnalyticsDividendsTabRefactored.tsx
import { PlusCircle } from 'lucide-react';

PlusCircle isn’t referenced elsewhere.

Fix: Remove the import if no icon is rendered, or add usage.

8. Plot component used but never imported
PortfolioOptimization.tsx uses <Plot> although the dynamic import is commented out:

 // Dynamically import Plotly to avoid SSR issues
 // const Plot = dynamic(() => import('react-plotly.js'), { ssr: false })

Why it’s a bug: <Plot> renders but there is no imported component, producing runtime errors.

Fix: Restore the dynamic import or replace <Plot> with a properly imported chart component.

9. Unused imports in backend_api_analytics.py
from datetime import datetime, date, timedelta
from decimal import Decimal

These imports aren’t referenced anywhere in the module.

Fix: Remove unused imports or make use of them.

10. Unused variable total_cost in backend_api_analytics.py
        portfolio_value = float(metrics.performance.total_value)
        total_cost = float(metrics.performance.total_cost)
        total_gain_loss = float(metrics.performance.total_gain_loss)

total_cost is assigned but never used.

Fix: Either remove total_cost or include it in the response if necessary.

These issues were confirmed by ESLint and flake8 outputs. Example ESLint output excerpt:

./src/app/analytics/components/AddDividendModal.tsx
5:36  Error: 'front_api_get_quote' is defined but never used
62:8  Warning: React Hook useEffect has a missing dependency: 'initialFormState'
...

And flake8 reported unused imports and style issues:

backend_simplified/backend_api_routes/backend_api_analytics.py:8:1: F401 'datetime.date' imported but unused
backend_simplified/backend_api_routes/backend_api_analytics.py:8:1: F401 'datetime.timedelta' imported but unused
backend_simplified/backend_api_routes/backend_api_analytics.py:9:1: F401 'decimal.Decimal' imported but unused

Addressing these problems will reduce lint errors and prevent potential runtime bugs.

Bugs

Function used before it is defined
safeFormatAllocation is referenced when creating the column definitions before it is declared. Because the variable is declared with const, this triggers a runtime ReferenceError in JavaScript due to the temporal‑dead‑zone for const declarations.

Fix: Move the safeFormatAllocation function above the column definition or convert it to a function declaration so it is hoisted.

Incorrect field name when parsing Alpha Vantage volume
The historical price loader attempts to read '5. volume' and falls back to '6. volume', but TIME_SERIES_DAILY_ADJUSTED uses '6. volume'. This can lead to volume always being 0.

Fix: Always read '6. volume' for TIME_SERIES_DAILY_ADJUSTED.

Logging decorator misused
In the authentication helper, DebugLogger.log_api_call (which returns a decorator) is called but its return value is ignored, so no logging occurs.

Fix: Apply it as a decorator (@DebugLogger.log_api_call(...)) or replace it with a direct logging call.

Truncated function definition
The log_jwt_operation function ends abruptly without closing the function body. This results in invalid Python syntax.

Fix: Complete the function body and add a terminating newline or return statement.

Cache expiration not honored
When saving to cache an expires_at timestamp is stored, but _get_from_cache only checks the entry’s creation time and never uses expires_at. Cached data may remain past its intended TTL.

Fix: Compare the stored expires_at with the current time when reading from cache, or drop the unused field.

Duplicate imports
main.py imports logging and asynccontextmanager twice and imports FastAPI a second time. This redundancy can be confusing and should be cleaned up.

Fix: Remove the duplicate import lines.

change_percent left as string
Quote parsing strips the percent sign but does not convert the value to a number. Consumers expecting a numeric change percentage must perform the conversion themselves.

Fix: convert to float:
change_percent = float(quote.get('10. change percent', '0%').replace('%', ''))

Strict environment variable requirement
config.py raises a ValueError if any of the required environment variables are unset, causing the application to exit at startup even in development or testing environments.

Fix: provide defaults or degrade gracefully instead of raising.

No return or else path in log_jwt_operation
Besides being truncated, the function only logs when has_token is false and otherwise does nothing, which may indicate missing logic for the normal case.

Fix: Complete the implementation so both cases are handled and the function exits cleanly.

Cached data TTL mismatch
Because _save_to_cache writes an expires_at value but _get_from_cache bases staleness on created_at, entries never expire according to their expires_at timestamps.

Fix: either remove expires_at or update _get_from_cache to use it when deciding if cached data is valid.

How to Fix

Addressing these issues involves code reorganization, correcting API field names, completing incomplete functions, and ensuring cache logic and imports are consistent. For example:

Move the safeFormatAllocation helper above its usage.

Replace '5. volume' with '6. volume'.

Apply @DebugLogger.log_api_call(...) properly.

Finish writing log_jwt_operation and ensure TTL logic uses expires_at.

Remove the duplicate imports in main.py and convert change_percent to a float.

Decide whether missing environment variables should raise errors or use defaults.