### LLM Task: Execute Step 2 - Create the `PortfolioMetricsManager`

#### **Goal:**

The goal of this step is to implement the `PortfolioMetricsManager` class. This service will act as the central orchestrator and the single entry point for any API request that needs comprehensive portfolio data. It will be responsible for managing the calculation process and caching the final, computed results.

#### **Why We Are Doing This:**

Our API route handlers in `backend_api_dashboard.py` and `backend_api_analytics.py` are currently too complex. They have to call multiple different services and stitch the data together themselves. This is inefficient and hard to maintain.

The `PortfolioMetricsManager` will solve this by abstracting away all the complexity. The API routes will make one simple call to the manager, and the manager will handle the difficult work of orchestrating the calculations, managing the cache, and returning a complete, consistent data object.

#### **What Needs to Be Done:**

1.  **Create a new file**: `services/portfolio_metrics_manager.py`.
2.  **Implement the `PortfolioMetricsManager` class** as outlined in the design document (`PortfolioMetricsManager.md`).
3.  The manager's primary method, `get_portfolio_metrics`, must be implemented to orchestrate the entire process of calculating a user's portfolio metrics.
4.  This manager must implement a caching layer for the **final, calculated portfolio metrics**. This cache should be stored in the Supabase database (e.g., in a new table named `portfolio_metrics_cache`). It should not use Redis.
5.  This manager will be the **single entry point** that the API routes will call. It will use the `PortfolioCalculator` for the actual math and the `PriceManager` to get price data.

#### **What Steps Must Be Taken Carefully:**

* **Orchestration Logic**: The `get_portfolio_metrics` method needs to correctly manage the `asyncio.gather` call to run calculations in parallel, as shown in the design document. It must correctly map the results from the gathered tasks back to the final `PortfolioMetrics` object.
* **Cache Key Generation**: The cache key must be unique and deterministic. It needs to account for all the input parameters (`portfolio_id`, `as_of_date`, etc.) to prevent serving stale or incorrect data. A poorly designed key will break the cache.
* **Error Handling**: The manager must be ableto gracefully handle potential errors from the downstream services it calls (like the `PortfolioCalculator` or `PriceManager`) and return a sensible error response to the API layer.

---

#### **LLM Task & Questions:**

Now, as the Language Model executing this task:

1.  **Give me your opinion** on this plan. Be blunt. Is creating this manager an unnecessary layer of abstraction, or is it a crucial separation of concerns? Are there any weaknesses in the proposed class structure from the design document?
2.  **Explain your understanding** of the manager's role. What is its primary responsibility in the new architecture?
3.  **How can you make this plan even better?** Based on the design, how would you improve the `PortfolioMetricsManager`? Suggest a specific enhancement to its logic or structure to make it even more robust or efficient.